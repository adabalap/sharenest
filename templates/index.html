{% extends "layout.html" %}
{% block content %}
<div class="card">
  <h2 id="card-title">Share a File</h2>
  <p id="card-subtitle">Upload a file, get a secure link.</p>

  <div id="form-view">
    <form id="upload-form">
      <div class="form-group">
        <div id="file-drop-zone">
          <p id="file-name-display">Drop a file here or click to select</p>
          <input id="file-upload" name="file" type="file" required>
        </div>
      </div>
      <div class="form-group">
        <label for="security_phrase">Security Phrase</label>
        <input type="password" name="security_phrase" id="security_phrase" minlength="4" required placeholder="At least 4 characters">
      </div>
      <div class="form-group">
        <button type="submit" class="btn btn-primary">Create Secure Link</button>
      </div>
    </form>
  </div>

  <div id="progress-view" class="hidden">
      <div id="progress-filename"></div>
      <div id="progress-percent">0%</div>
      <div class="progress-bar-container">
          <div id="progress-bar" style="width: 0%"></div>
      </div>
      <div id="progress-status"></div>
      <div id="progress-eta"></div>
  </div>

  <div id="result-view" class="hidden"></div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    const CONCURRENCY_LIMIT = 5;
    const form = document.getElementById('upload-form');
    const fileInput = document.getElementById('file-upload');
    const fileNameDisplay = document.getElementById('file-name-display');
    const dropZone = document.getElementById('file-drop-zone');
    const submitButton = form.querySelector('button[type="submit"]');

    const cardTitle = document.getElementById('card-title');
    const cardSubtitle = document.getElementById('card-subtitle');
    
    const formView = document.getElementById('form-view');
    const progressView = document.getElementById('progress-view');
    const resultView = document.getElementById('result-view');

    const progressFileName = document.getElementById('progress-filename');
    const progressPercent = document.getElementById('progress-percent');
    const progressBar = document.getElementById('progress-bar');
    const progressStatus = document.getElementById('progress-status');
    const progressEta = document.getElementById('progress-eta');

    let startTime;

    function switchView(view) {
        formView.classList.add('hidden');
        progressView.classList.add('hidden');
        resultView.classList.add('hidden');
        if (view === 'form') {
            formView.classList.remove('hidden');
            cardTitle.textContent = 'Share a File';
            cardSubtitle.textContent = 'Upload a file, get a secure link.';
        } else if (view === 'progress') {
            progressView.classList.remove('hidden');
            cardTitle.textContent = 'Uploading...';
        } else if (view === 'result') {
            resultView.classList.remove('hidden');
        }
    }

    function handleFileSelect(files) {
        if (files.length > 0) {
            const file = files[0];
            fileInput.files = files;
            fileNameDisplay.textContent = `${file.name} (${formatBytes(file.size)})`;
        }
    }

    fileInput.addEventListener('change', () => handleFileSelect(fileInput.files));
    dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('dragover'); });
    dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
    dropZone.addEventListener('drop', (e) => {
        e.preventDefault();
        dropZone.classList.remove('dragover');
        handleFileSelect(e.dataTransfer.files);
    });
    dropZone.addEventListener('click', () => fileInput.click());

    form.addEventListener('submit', async (e) => {
        e.preventDefault();
        const file = fileInput.files[0];
        const pin = document.getElementById('security_phrase').value;

        if (!file) { showError('Please select a file to upload.'); return; }
        if (pin.length < 4) { showError('Security phrase must be at least 4 characters.'); return; }

        setFormDisabled(true);
        startTime = Date.now();
        switchView('progress');
        progressFileName.textContent = file.name;
        updateProgressUI(0, file.size, 'Initializing...');

        try {
            const initResponse = await fetch('/api/initiate-upload', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ filename: file.name, file_size_bytes: file.size }),
            });

            if (!initResponse.ok) {
                const err = await initResponse.json();
                throw new Error(err.error || 'Could not initiate upload.');
            }

            const result = await initResponse.json();
            
            if (result.upload_type === 'direct') {
                await directUpload(file, pin, result.par_url, result.object_name);
            } else if (result.upload_type === 'multipart') {
                await multipartUpload(file, pin, result);
            }

        } catch (error) {
            showError(error.message);
        }
    });

    function setFormDisabled(disabled) {
        submitButton.disabled = disabled;
        fileInput.disabled = disabled;
        document.getElementById('security_phrase').disabled = disabled;
    }

    function updateProgressUI(loaded, total, statusText) {
        const percent = total > 0 ? Math.round((loaded / total) * 100) : 0;
        progressBar.style.width = `${percent}%`;
        progressPercent.textContent = `${percent}%`;
        progressStatus.textContent = statusText;

        if (startTime && loaded > 0 && total > 0) {
            const elapsedTime = (Date.now() - startTime) / 1000; // in seconds
            const uploadSpeed = loaded / elapsedTime; // bytes per second
            const remainingBytes = total - loaded;
            const etaSeconds = remainingBytes / uploadSpeed;

            if (isFinite(etaSeconds) && etaSeconds > 0) {
                progressEta.textContent = `ETA: ${formatTime(etaSeconds)}`;
            } else {
                progressEta.textContent = '';
            }
        } else {
            progressEta.textContent = '';
        }
    }

    function formatTime(seconds) {
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = Math.round(seconds % 60);
        if (minutes > 0) {
            return `${minutes}m ${remainingSeconds}s`;
        } else {
            return `${remainingSeconds}s`;
        }
    }

    async function directUpload(file, pin, parUrl, objectName) {
        await uploadWithXHR(parUrl, file, (loaded, total) => {
            updateProgressUI(loaded, total, `Uploading... ${formatBytes(loaded)} / ${formatBytes(total)}`);
        });
        await finalizeUpload(pin, file.name, objectName, file.size);
    }

    async function multipartUpload(file, pin, { object_name, part_size_bytes, par_url }) {
        const totalParts = Math.ceil(file.size / part_size_bytes);
        let loadedSoFar = 0;
        
        // 1. Initiate Multipart Upload to get the uploadId from OCI
        updateProgressUI(0, file.size, 'Initializing multipart upload...');
        const initiateMultipartResponse = await fetch(`${par_url}?uploads`, { method: 'POST' });
        if (!initiateMultipartResponse.ok) {
            throw new Error('Could not initiate multipart upload with storage provider.');
        }
        const initiateMultipartData = await initiateMultipartResponse.json();
        const uploadId = initiateMultipartData.uploadId;

        if (!uploadId) {
            throw new Error('Failed to get a valid upload ID from storage provider.');
        }

        // 2. Create and execute upload tasks for each part
        const partUploadTasks = [];
        for (let i = 0; i < totalParts; i++) {
            const partNum = i + 1;
            const start = i * part_size_bytes;
            const end = Math.min(start + part_size_bytes, file.size);
            const chunk = file.slice(start, end);
            const partUrl = `${par_url}?partNumber=${partNum}&uploadId=${uploadId}`;

            partUploadTasks.push(async () => {
                const MAX_RETRIES = 3;
                for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
                    try {
                        const etag = await uploadWithXHR(partUrl, chunk, (partLoaded, partTotal) => {
                            // This progress is for a single part. We update the overall progress below.
                        });
                        loadedSoFar += chunk.size;
                        updateProgressUI(loadedSoFar, file.size, `Uploading part ${partNum} of ${totalParts}...`);
                        return { partNum, etag };
                    } catch (error) {
                        console.error(`Error uploading part ${partNum}, attempt ${attempt}/${MAX_RETRIES}:`, error);
                        if (attempt === MAX_RETRIES) {
                            throw new Error(`Failed to upload part ${partNum} after ${MAX_RETRIES} attempts.`);
                        }
                        await new Promise(resolve => setTimeout(resolve, 1000 * attempt)); // Backoff
                    }
                }
            });
        }

        const uploadedParts = await throttlePromises(partUploadTasks, CONCURRENCY_LIMIT);
        const sortedParts = uploadedParts.filter(Boolean).sort((a, b) => a.partNum - b.partNum);

        if (sortedParts.length !== totalParts) {
            // Abort the multipart upload on OCI's side
            await fetch(`${par_url}?uploadId=${uploadId}`, { method: 'DELETE' });
            throw new Error('One or more parts failed to upload. The upload has been aborted.');
        }

        // 3. Commit the multipart upload with OCI
        updateProgressUI(file.size, file.size, 'Committing upload...');
        const commitPayload = { parts: sortedParts.map(p => ({ partNum: p.partNum, etag: p.etag })) };
        const commitResponse = await fetch(`${par_url}?uploadId=${uploadId}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(commitPayload),
        });

        if (!commitResponse.ok) {
            const errorBody = await commitResponse.text();
            console.error("Commit failed response:", errorBody);
            throw new Error('Failed to commit the multipart upload with the storage provider.');
        }

        // 4. Finalize with our backend
        // For PAR flow, we don't send upload_id or parts to our own server.
        await finalizeUpload(pin, file.name, object_name, file.size);
    }

    function uploadWithXHR(url, body, onProgress) {
        return new Promise((resolve, reject) => {
            const xhr = new XMLHttpRequest();
            xhr.open('PUT', url, true);
            xhr.upload.onprogress = (e) => {
                if (e.lengthComputable) onProgress(e.loaded, e.total);
            };
            xhr.onload = () => {
                if (xhr.status >= 200 && xhr.status < 300) {
                    let etag = xhr.getResponseHeader('ETag');
                    if (etag) {
                        // Strip surrounding quotes if present
                        etag = etag.replace(/^"|"$/g, '');
                    }
                    if (!etag) {
                        console.error('ETag header missing from upload response for URL:', url);
                        reject(new Error('ETag header missing from upload response.'));
                        return;
                    }
                    console.log(`Part uploaded. URL: ${url}, ETag: ${etag}`);
                    resolve(etag);
                } else {
                    reject(new Error(`Upload failed with status: ${xhr.status}`));
                }
            };
            xhr.onerror = () => reject(new Error('A network error occurred during upload.'));
            xhr.send(body);
        });
    }

    async function finalizeUpload(pin, original_filename, object_name, size_bytes, upload_id = null, parts = null) {
        updateProgressUI(size_bytes, size_bytes, 'Finalizing...');
        const body = { pin, original_filename, object_name, size_bytes, upload_id, parts };
        
        const finalizeResponse = await fetch('/api/finalize-upload', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body),
        });

        if (!finalizeResponse.ok) {
            const err = await finalizeResponse.json();
            throw new Error(err.error || 'Could not finalize upload.');
        }

        const result = await finalizeResponse.json();
        showSuccess(result);
    }

    function showSuccess(data) {
        switchView('result');
        cardTitle.textContent = 'Link Created!';
        cardSubtitle.textContent = 'Your secure link is ready to be shared.';
        resultView.innerHTML = `
            <div class="share-link-wrapper">
              <p>Your file <strong class="filename">${escapeHTML(data.filename)}</strong> is ready to be shared.</p>
              <div class="share-link-container">
                <label for="share-url-input">Share Link (expires in ${data.expiry_pretty})</label>
                <div class="share-link-input-wrapper">
                  <input id="share-url-input" type="text" value="${escapeHTML(data.share_url)}" readonly>
                  <button id="copy-btn" class="btn btn-secondary">Copy</button>
                </div>
              </div>
              <button id="reset-button" class="btn btn-primary">Share Another File</button>
            </div>`;
        
        document.getElementById('copy-btn').addEventListener('click', (e) => {
            copyToClipboard(data.share_url, 'Share link copied!');
            e.target.textContent = 'Copied!';
            setTimeout(() => { e.target.textContent = 'Copy'; }, 2000);
        });
        document.getElementById('reset-button').addEventListener('click', resetToForm);
    }

    function showError(message) {
        switchView('result');
        cardTitle.textContent = 'Upload Error';
        cardSubtitle.textContent = ''; // No subtitle for errors
        resultView.innerHTML = `
            <div class="error-message">
              <h3>Upload Error</h3>
              <p>${escapeHTML(message)}</p>
            </div>
            <button id="reset-button" class="btn btn-primary">Try Again</button>`;
        document.getElementById('reset-button').addEventListener('click', resetToForm);
    }
    
    function resetToForm() {
        form.reset();
        fileNameDisplay.textContent = 'Drop a file here or click to select';
        setFormDisabled(false);
        switchView('form');
    }

    function formatBytes(bytes, decimals = 2) {
        if (!+bytes) return '0 Bytes';
        const k = 1024;
        const dm = decimals < 0 ? 0 : decimals;
        const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`;
    }

    // Helper to run promises with a concurrency limit
    async function throttlePromises(tasks, limit) {
        const results = new Array(tasks.length);
        const running = [];
        let i = 0;

        function runNext() {
            if (i < tasks.length) {
                const currentIndex = i++;
                const task = tasks[currentIndex];
                const promise = task();

                const inFlight = promise.then(result => {
                    results[currentIndex] = result;
                    running.splice(running.indexOf(inFlight), 1);
                    return runNext();
                });
                running.push(inFlight);
                return inFlight;
            }
        }

        // Start initial tasks
        const initialPromises = [];
        for (let j = 0; j < limit && j < tasks.length; j++) {
            initialPromises.push(runNext());
        }

        return Promise.all(initialPromises).then(() => Promise.all(running));
    }

    function escapeHTML(str) {
        return str.replace(/[&<>"']/g, match => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[match]));
    }
});
</script>
{% endblock %}